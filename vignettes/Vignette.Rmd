---
title: "Visualization with `anvis`"
author:
- name: Robert Koetsier
  affiliation: Wageningen University, Wageningen, The Netherlands
- name: Sanjeevan Jahagirdar
  affiliation: Wageningen University, Wageningen, The Netherlands
output: 
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
    toc_float: true
package: anvis
abstract: >
  Creating and customizing network visualizations.
vignette: >
  %\VignetteIndexEntry{Visualization with anvis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  fig.height = 7, # Set default for showing a single network 
  fig.width = 8
)
```

# Introduction 

## About `anvis`

The `anvis` package was developed to automate the process of creating network visualizations. It generates visual styling for network properties to highlight the most relevant features. In addition, the package is prudently suited to create multiple network comparisons to study different states of the given system. The basic visualization tools and functions (pre-requisite to applying anvis skins) are imported from popular network visualization platforms: `r CRANpkg("igraph")`, and [Cytoscape](https://cytoscape.org/) (via `r Biocpkg("RCy3")`). Any user familiar with these software packages will be easily able to extend and customize the visualizations made with `anvis`. `anvis` can be integrated in any user-defined analysis pipeline, to this end `anvis` offers exports of networks and the added attributes (e.g. node size and edge color) in various common formats. Relatively small networks offer optimal results, so it is recommended to include a maximum of 100 nodes (variables) or 500 edges (similarity scores or similar relations). 

* Brief review of similar packages (create a list and discuss with Sanjee, possibly integrate this: For visualization of larger networks we refer users to the package `r Biocpkg("netbiov")`, as this package offers a variety of options aimed at visualization of large networks.)
* short motivation of the package (copy from fellowship application)

## Installation

For installation of the package run the following code:

```{r installation, eval=FALSE}
if (!requireNamespace("BiocManager", quietly=TRUE))
    install.packages("BiocManager")
BiocManager::install("anvis")
```


## Brief demonstration of core functionalities

We will start by giving some demonstrations of the core functionalities of the 
package. Start by loading the package.

```{r loading}
library(anvis)
```

### Input data

`anvis` uses network data, which can be provided in multiple formats: 'graphNEL', 
'igraph', list of dataframes, or adjacency matrix. Two example 
datasets (`sepsis` and `paleo`) are integrated in the package and can be used for 
trying out the functions of `anvis`. Here, we use `sepsis` to showcase 
some key features. The `sepsis` dataset
consists of multiple adjacency matrices that show how similar the levels of 
selected proteins behave in different groups of hospital patients
(run `?sepsis` for more info).

The first matrix of `sepsis` looks as follows:

```{r sepsis_demo}
data1 <- sepsis[[1]]

# Show only part of the data and round to 3 decimals 
round(data1[1:15, 1:6], 3)

```

The above data shows partial correlations between protein levels. We will convert
the adjacency matrix into an object of a network data class in one of the 
following steps. 

Before this, we group the proteins of our example dataset, since this can yield 
more interesting visualizations later. In this case, we
will assign proteins into groups based on their protein family (shared parts 
of their name). 

```{r preview_create_groups}
# Create a vector that holds the names of all proteins
proteins <- colnames(data1)
proteins

# Assign a group label to each protein
# We find multiple proteins that include "IL", "CCL", or "CXCL" in their name.
#   These will be assigned their own group label
groups <- dplyr::case_when(
    stringr::str_starts(proteins, "IL") ~ "group A", 
    stringr::str_starts(proteins, "CCL") ~ "group B", 
    stringr::str_starts(proteins, "CXCL") ~ "group C", 
    TRUE ~ "group D")  # All other proteins will be group D
groups
```

### Preparing the network for visualization

Before making a visualization, we need to add additional attributes to our data
that will help with the visual styling of the network. `anvis` provides functions
to automate this process. The function `adjToNetwork` creates a network from an adjacency
matrix and adds additional attributes, the function `addVisAttrs` adds attributes
to an existing network of type "graphNEL", "igraph", or list of dataframes.

Since our example data is an adjacency matrix we will use `adjToNetwork` here. 
Possible output types for the network are "graphNEL", "igraph", or list of 
dataframes. Here we selected "igraph" as output type, since this will make it 
easy to demonstrate which attributes have been added to the network. 

```{r preview_attrs}
# Create network from adjacency, add all attributes for visual styling, 
#    incorporate group information.
net1 <- adjToNetwork(adj_mats = data1, 
                     node_attrs = "all", 
                     edge_attrs = "all", 
                     group_vec = groups,
                     output_as = "igraph")

# We chose to get an igraph object as output, below some info about this
#   network object
net1

# get edge attributes
igraph::list.edge.attributes(net1)

# get node attributes
igraph::list.vertex.attributes(net1)
```

We're left with a network that has a node for each protein and and edge to 
represent all non-zero partial correlations between the proteins. The additional
attributes that have been added for the edges are "width" and "color". These 
were determined based on the partial correlation values. Nodes have additional 
attributes "group", and "color" based on the groups they are assigned to, and 
attribute "size" based on the sum of the edges that are connected to a node. 

### Visualization of the network

Once additional attributes have been added to a network, we make use of the 
`anvis()` function to visualize it. `anvis()` offers a variety of options to 
customize the visualization. In addition, it can use different software 
(`r CRANpkg("igraph")`, and [Cytoscape](https://cytoscape.org/)) to generate the
visualization, or export the final network in various different formats. For now,
we make a basic visualization using the defaults (`igraph` will be used to 
generate our output). Other options will be showcased later in this vignette. 

```{r preview_fig, fig.height=7, fig.width=8}
anvis(net1)
```

# Example data available with package

We have included two datasets with the package so its functions can be 
tested. `sepsis` relates to protein levels in the blood of hospital patients, 
`paleo` relates to the abundance of chemical elements detected in ocean ground
drilling. Throughout this vignette we will use this data to showcase the 
package's features. More background on the datasets follows:

### `sepsis`

The levels of 36 selected proteins was measured in the plasma of hospital patients 
with one of three varieties of soft tissue infections (necrotizing soft tissue infection, 
non-necrotizing soft tissue infection, and cellulitis), and a in surgical control group.
Patients were divided into 12 groups based on characteristics of their disease. 
To create the groups, a distinction was made between the type of disease, whether
patients had a septic shock, and whether their disease had a mono-microbial or 
poly-microbial origin. Within each group, partial correlation was calculated 
between the level of the proteins, to generate the `sepsis` dataset. `sepsis`
is a list with 12 elements, each of which is an adjacency matrix of 36 rows and
columns, representing the similarity in the levels of the proteins measured in 
the patients (`?sepsis` for more info).


### `paleo`

To study the environmental change that occurred in the late Paleocene-early Eocene
period, deep sea drilling experiments were performed. The levels of trace elements
in the sediment of the sea were measured at different depths. The `paleo` dataset
is an adjacency matrix containing partial correlations that were calculated 
between the levels of the elements measured in the experiments. `paleo_mi` is 
a similar adjacancy matrix, containing mutual information values instead of 
partial correlation values (`?paleo` or `?paleo_mi` for more info). 

# Data input

`anvis` functions can use used with different types of network data. Depending 
on which data will be available, slightly different functions should be used

## Input of adjacency matrices

Adjacency matrices can be a valid input for creating visualizations with `anvis`, 
if they are square and contain names for the rows and columns. A single matrix 
may be used, or a list of several. Before a visualization can be made, the 
adjacency matrices should be converted into a network object. This can be done
with the function `adjToNetwork`. As demonstrated below, this function provides
the option to create directed networks and show self interactions between nodes
if this is relevant. 

```{r adj_to_net, fig.height=16}
# create network from 'paleo' (adjacency matrix)
net1 <- adjToNetwork(paleo)
net2 <- adjToNetwork(paleo, directed = T)
net3 <- adjToNetwork(paleo, directed = T, self_loops = T)

# add networks to a list
paleo_nets <- list("undirected" = net1, "directed" = net2, "self loops" = net3)

# Visualize the networks to show their different properties, for now make 
#   seperate visualizations for each network instead of showing them in a grid
anvis(paleo_nets, igr_grid = c(3,1), igr_grid_names = T)
```

For the `paleo` data having directed edges or self loops is not very informative,
as the adjacency matrix is symmetrical and all nodes have a perfect partial 
correlation with themselves. 

Use of `adjToNetwork` will by default return a network object of class `"graphNEL"`.
Depending on the workflow that the newly created network will be subjected to, 
other classes might be more relevant. For these cases, the parameter 'output_as'
of `adjToNetwork` can be changed to "igraph" or "list". 

The purpose of `adjToNetwork` is twofold. First, as demonstrated, it converts an
adjacency matrix into a network class object. Second, it adds additional 
attributes to the network that can be useful to create more clear visualizations.
Most of these attributes are added by default. However, there is a set of additional 
options that allows for customization and extension of the attributes that are 
added. These options will be explained in a following section. For adding 
attributes to networks, 
`adjToNetwork` uses the same parameters as the `addVisAttr` function, and can 
therefore be used in a similar way. 
    
## Input of network objects

With `anvis`, any network of class `"graphNEL"`, `"igraph"`, or list of data 
frames `"vertices"` and `"edges"` can be manipulated and visualized. To make use of the 
full set of features of `anvis`, networks require and edge weight attribute. 

To create a styled visualization of a network with `anvis`, first several 
attributes need to be added. The function `addVisAttr` automates this task. 
It comes with various options to customize the added attributes. This will
be elaborated in detail in the next section. 

# Adding attributes to networks

For making visualizations we add attributes, such as node group, color, and size,
and edge color and width, to networks. These attributes can all be added in a single step 
using `adjToNetwork` or `addVisAttr`. To demonstrate the available options we 
add the attributes individually below, and show which choices are available for
customization.

## No additional attributes

Addition of attributes to the network can be skipped, resulting in the most 
basic visualization. 

```{r no_attrs}
# We create a basic network from the paleo adjacency matrix, without additional
#   attributes. 
# This can be skipped if a network object is already available
paleo_net0 <- adjToNetwork(paleo, node_attrs = "none", edge_attrs = "none")

# In other code chunks paleo_net0 stays without additional attributes,
#   paleo_net might be altered
paleo_net <- paleo_net0

# Visualize without adding attributes
title <- "Network without additional attributes"
anvis(paleo_net, igr_plot_opts = list(main = title))
```

## Node groups and colors

Todo: 

* group vector either one for all networks or one for each

Nodes can be assigned to a group. This will place all nodes with the same group
label adjacent to each other in the visualization. To make distinction of groups easier,
each group can be assigned a color. The following code chunk shows how the group 
attribute can be added and which additional options are available.

```{r groups}
# get the nodes of the network
nodes_paleo <- graph::nodes(paleo_net)

# Create vector with group labels for each node
groups_paleo <- dplyr::case_when(
    stringr::str_detect(nodes_paleo, "%") ~ "group %", 
    stringr::str_detect(nodes_paleo, "kg") ~ "group mg/kg", 
    stringr::str_detect(nodes_paleo, "/Al") ~ "group /Al", 
    TRUE ~ "others") 

# Add group attribute
paleo_net <- addVisAttrs(paleo_net, node_attrs = "group", edge_attrs = "none", 
                         group_vec = groups_paleo)

# Visualize grouped network
title <- "Network with group attribute (nodes reordered)"
anvis(paleo_net, igr_plot_opts = list(main = title))

# Now also add colors for the groups
paleo_net <- addVisAttrs(paleo_net, node_attrs = "color_group", edge_attrs = "none")

# Visualization with group colors
title <- "Network with group and color_group (node 'color' attribute)"
anvis(paleo_net, igr_plot_opts = list(main = title))

# `colorblind` argument can be used to create node colors or overwrite them 
#   with colorblind accessible colors
paleo_net <- addVisAttrs(paleo_net, node_attrs = "color_group", edge_attrs = "none", 
                         colorblind = TRUE)

# Show network with colorblind accessible colors
title <- "Network with colorblind accessible colors"
anvis(paleo_net, igr_plot_opts = list(main = title))

# Custom colors can be used with "color_group"
custom_cols <- c("#4E79A7", "#F28E2B", "#E15759", "#76B7B2") # from ggthemes::tableau_color_pal(palette = "Tableau 10")(4)
paleo_net <- addVisAttrs(paleo_net, node_attrs = "color_group", edge_attrs = "none", 
                         group_colors = custom_cols)

# Show network with custom group colors
title <- "Network with custom group colors"
anvis(paleo_net, igr_plot_opts = list(main = title))
```

## Node size

A node size attribute can be added to networks with `adjToNetwork` or 
`addVisAttr`. To determine node sizes, these functions will determine the 
connectivity of a node by calculating the sum of 
all edges associated with it. The values for all nodes are scaled to range 0 to 1, and transformed
with a sigmoid to enhance the contrast of node sizes. Finally, node sizes are 
multiplied with a constant factor that is determined by the argument 'size_type'.
This will make sure that different output methods (igraph, Cytoscape, or export)
can be used with node sizes that match their defaults. 

```{r node_size}
# Add node size attribute
paleo_net <- addVisAttrs(paleo_net, node_attrs = "size", edge_attrs = "none")

# Visualize network with node size attribute
title <- "Network with node size determined by connectivity"
anvis(paleo_net, igr_plot_opts = list(main = title))

# When using cytoscape for visualization it's best to adjust node sizes to
#   Cytoscape's defaults. This can be done with the 'size_type' argument
# paleo_net <- addVisAttrs(paleo_net, node_attrs = "size", edge_attrs = "none", 
#                          size_type = "cytoscape")

# Visualize network with node size attribute
# anvis(paleo_net, output_type = "cytoscape")  ## Run only when cytoscape is active
```

The options that can be used with 'size_type' are: "igraph" (default), so node
sizes will be in the range 3 to 15, "cytoscape", nodes will be in the range 7 to
27, and "scaled_only" for nodes in range 0 to 1. 

When node sizes are added, it is possible to reorder the nodes based on the value
of this attribute. For this, the argument 'arrange_co' (for: arrange by connectivity) 
can be set to `TRUE`. If groups are found in the data, the nodes will be arranged
by connectivity inside the groups. We demonstrate this in the following.

```{r arrange_co}
# Add no new attribute, but arrange by connectivity
paleo_net <- addVisAttrs(paleo_net, 
                         node_attrs = "none", 
                         edge_attrs = "none",
                         arrange_co = TRUE)

title <- "Network with nodes arranged by connectivity"
anvis(paleo_net, igr_plot_opts = list(main = title))
```

## Edge width

* The argument in the wrapper is vectorized

To distinguish between stronger and weaker connections between nodes, the edge 
'width' attribute can be added to a network. Using edge weight as edge width is 
not always appropriate, because different ranges of values may be 
found in networks to describe the strength of the association between nodes. 
For example, the range of correlations is between
-1 and 1, while the range of mutual information values may be between 0 and +Inf.
Consequently, these values need to be transformed so they can be used as edge 
widths. `anvis` offers 5 algorithms for converting edge weights into useful edge 
widths. The algorithms can be set via the argument 'width_type' of `adjToNetwork`
and `addVisAttr`. The possible choices for this argument are: 

"cor", which is intended to be used with Pearson or Spearman correlation values 
(range -1 to 1). Widths will be the absolute value of the correlation, scaled 
with a sigmoid. "partcor", which is intended to be use for partial correlation 
values (range -1 to 1). For this method, edge widths will be the cube root of 
absolute weight values, scaled with a sigmoid. The option "MI" is meant to be 
used with weights derived from mutual information (range 0 to +∞). Widths will 
be the weights divided by to maximum weight, then scaled with a sigmoid. 
"default_scaling" applies the same transformation as "MI", as a result scaling 
the any weights to range 0 to 1. "ranked" will calculate percentage ranks of the 
weight, and scale them with a sigmoid. "percentile" will chose a set of fixed 
widths determined by the percentile of a weight value. The highest percentiles 
will be assigned the largest width, but they are the smallest group, vice versa 
for the lowest percentiles. 

* there is an option available to rescale these edge widths
   
   
## Edge colors

### Available color spectra

* Diverging and sequential
    
### Changing edge colors with custom color function

* `Rcoloramp` can be used to convert colors to a spectrum. 
* demonstrate how to flip color spectra: 

```{r color_func}
# when the colors are opposite of what you expect
my_cols <- function (n) rev(pals::magma(n))
```

* Colors go from low to high values
* for positive and negative weights the colors are split into two halves, to be assigned to either sign





# Visualizing with igraph


## Changing the layout of the nodes

* Explain how alternative layouts can be used, and how the node order can be maintained


## Visualization of multiple networks

* Options to visualize side by side
* manually adjust the layout of the grid
* add titles to the grid elements, either by hand or from the names of the list
* Point out that it can be helpful to change the margins

## Further customization

* give some examples, to demonstrate that the full set of options of igraph is still available
    + Change graphical parameter options with `par()` 
    + Various options because of the flexibility of igraph
    + radial labels have their own options to be adjusted

## Directionality

* Arrows, self loops
* Recommend to use cytoscape instead of igraph since it looks neater



# Visualizing cytoscape


## Options for showing the visualizations

* Save image
    + export types
    + further export options
* Saving session
* Close session


## Visualization of multiple networks

* Multiple networks can be visualized, but they are either show in the session or saved seperately. No option to show side by side. 
* One option to show graphs side by side: - [arrange network windows](http://manual.cytoscape.org/en/stable/Quick_Tour_of_Cytoscape.html#:~:text=Arrange%20Network%20Windows)
* for easiest comparison we recommend igraph


## Directionality

* Arrows, self loops


## Customization 

* Setting more node space


## Using `r Biocpkg("RCy3")` for further customization

* Show at least one example to change some visual features of the network.


# Exporting the networks

* make a note on how the exports can include the columns that have info for visual styling
* Example with xgmml and another type
* file save name and xgmml title

##  saving of the visualizations

* export types
* further export options

# Session info

This vignette was made with `r CRANpkg("rmarkdown")` and `r Biocpkg("BiocStyle")`. Below the output generated by `sessionInfo()` when this document was compiled:

```{r sessionInfo, echo=FALSE}
sessionInfo()
```


