---
title: "Visualization with `anvis`"
author:
- name: Robert Koetsier
  affiliation: Wageningen University, Wageningen, The Netherlands
- name: Sanjeevan Jahagirdar
  affiliation: Wageningen University, Wageningen, The Netherlands
output: 
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
    toc_float: true
package: anvis
abstract: >
  Creating and customizing network visualizations.
vignette: >
  %\VignetteIndexEntry{Visualization with anvis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction 

## About `anvis`

The `anvis` package was developed to automate the process of creating network visualizations. It generates visual styling for network properties to highlight the most relevant features. In addition, the package is prudently suited to create multiple network comparisons to study different states of the given system. The basic visualization tools and functions (pre-requisite to applying anvis skins) are imported from popular network visualization platforms: `r CRANpkg("igraph")`, and [Cytoscape](https://cytoscape.org/) (via `r Biocpkg("RCy3")`). Any user familiar with these software packages will be easily able to extend and customize the visualizations made with `anvis`. `anvis` can be integrated in any user-defined analysis pipeline, to this end `anvis` offers exports of networks and the added attributes (e.g. node size and edge color) in various common formats. Relatively small networks offer optimal results, so it is recommended to include a maximum of 100 nodes (variables) or 500 edges (similarity scores or similar relations). 

* Brief review of similar packages (create a list and discuss with Sanjee, possibly integrate this: For visualization of larger networks we refer users to the package `r Biocpkg("netbiov")`, as this package offers a variety of options aimed at visualization of large networks.)
* short motivation of the package (copy from fellowship application)

## Installation

For installation of the package run the following code:

```{r installation, eval=FALSE}
if (!requireNamespace("BiocManager", quietly=TRUE))
    install.packages("BiocManager")
BiocManager::install("anvis")
```


## Brief demonstration of core functionalities

We will start by giving some demonstrations of the core functionalities of the 
package. Start by loading the package.

```{r loading}
library(anvis)
```

### Input data

`anvis` uses network data, which can be provided in multiple formats: 'graphNEL', 
'igraph', list of dataframes, or adjacency matrix. Two example 
datasets (`sepsis` and `paleo`) are integrated in the package and can be used for 
trying out the functions of `anvis`. Here, we use `sepsis` to showcase 
some key features. The `sepsis` dataset
consists of multiple adjacency matrices that show how similar the levels of 
selected proteins behave in different groups of hospital patients
(run `?sepsis` for more info).

The first matrix of `sepsis` looks as follows:

```{r sepsis_demo}
data1 <- sepsis[[1]]

# Show only part of the data and round to 3 decimals 
round(data1[1:15, 1:6], 3)

```

The above data shows partial correlations between protein levels. We will convert
the adjacency matrix into an object of a network data class in one of the 
following steps. 

Before this, we group the proteins of our example dataset, since this can yield 
more interesting visualizations later. In this case, we
will assign proteins into groups based on their protein family (shared parts 
of their name). 

```{r create_groups}
# Create a vector that holds the names of all proteins
proteins <- colnames(data1)
proteins

# Assign a group label to each protein
# We find multiple proteins that include "IL", "CCL", or "CXCL" in their name.
#   These will be assigned their own group label
groups <- dplyr::case_when(
    stringr::str_starts(proteins, "IL") ~ "group A", 
    stringr::str_starts(proteins, "CCL") ~ "group B", 
    stringr::str_starts(proteins, "CXCL") ~ "group C", 
    TRUE ~ "group D")  # All other proteins will be group D
groups
```

### Preparing the network for visualization

Before making a visualization, we need to add additional attributes to our data
that will help with the visual styling of the network. `anvis` provides functions
to automate this process. The function `adjToNetwork` creates a network from an adjacency
matrix and adds additional attributes, the function `addVisAttrs` adds attributes
to an existing network of type "graphNEL", "igraph", or list of dataframes.

Since our example data is an adjacency matrix we will use `adjToNetwork` here. 
Possible output types for the network are "graphNEL", "igraph", or list of 
dataframes. Here we selected "igraph" as output type, since this will make it 
easy to demonstrate which attributes have been added to the network. 

```{r}
# Create network from adjacency, add all attributes for visual styling, 
#    incorporate group information.
net1 <- adjToNetwork(adj_mats = data1, 
                     node_attrs = "all", 
                     edge_attrs = "all", 
                     group_vec = groups,
                     output_as = "igraph")

# We chose to get an igraph object as output, below some info about this
#   network object
net1

# get edge attributes
igraph::list.edge.attributes(net1)

# get node attributes
igraph::list.vertex.attributes(net1)
```

We're left with a network that has a node for each protein and and edge to 
represent all non-zero partial correlations between the proteins. The additional
attributes that have been added for the edges are "width" and "color". These 
were determined based on the partial correlation values. Nodes have additional 
attributes "group", and "color" based on the groups they are assigned to, and 
attribute "size" based on the sum of the edges that are connected to a node. 

### Visualization of the network

Once additional attributes have been added to a network, we make use of the 
`anvis()` function to visualize it. `anvis()` offers a variety of options to 
customize the visualization. In addition, it can use different software 
(`r CRANpkg("igraph")`, and [Cytoscape](https://cytoscape.org/)) to generate the
visualization, or export the final network in various different formats. For now,
we make a basic visualization using the defaults (`igraph` will be used to 
generate our output). Other options will be showcased later in this vignette. 

```{r, fig.height=7}
anvis(net1)
```

# Example data available with package

We have included two datasets with the package so its functions can be 
tested. `sepsis` relates to protein levels in the blood of hospital patients, 
`paleo` relates to the abundance of chemical elements detected in ocean ground
drilling. Throughout this vignette we will use this data to showcase the 
package's features. More background on the datasets follows:

### `sepsis`

The levels of 36 selected proteins was measured in the plasma of hospital patients 
with one of three varieties of soft tissue infections (necrotizing soft tissue infection, 
non-necrotizing soft tissue infection, and cellulitis), and a in surgical control group.
Patients were divided into 12 groups based on characteristics of their disease. 
To create the groups, a distinction was made between the type of disease, whether
patients had a septic shock, and whether their disease had a mono-microbial or 
poly-microbial origin. Within each group, partial correlation was calculated 
between the level of the proteins, to generate the `sepsis` dataset. `sepsis`
is a list with 12 elements, each of which is an adjacency matrix of 36 rows and
columns, representing the similarity in the levels of the proteins measured in 
the patients (`?sepsis` for more info).


### `paleo`

To study the environmental change that occurred in the late Paleocene-early Eocene
period, deep sea drilling experiments were performed. The levels of trace elements
in the sediment of the sea were measured at different depths. The `paleo` dataset
is an adjacency matrix containing partial correlations that were calculated 
between the levels of the elements measured in the experiments. `paleo_mi` is 
a similar adjacancy matrix, containing mutual information values instead of 
partial correlation values (`?paleo` or `?paleo_mi` for more info). 

# Data preparation

`anvis` functions can use used with different types of network data. Depending 
on which data will be available, slightly different functions should be used

## Input of adjacency matrices

Adjacency matrices can be a valid input for creating visualizations with `anvis`, 
if they are square and contain names for the rows and columns. A single matrix 
may be used, or a list of several. Before a visualization can be made, the 
adjacency matrices should be converted into a network object. This can be done
with the function `adjToNetwork`. As demonstrated below, this function provides
the option to create directed networks and show self interactions between nodes
if this is relevant. 

```{r adj_to_net, fig.height=16}
# create network from 'paleo' (adjacency matrix)
net1 <- adjToNetwork(paleo)
net2 <- adjToNetwork(paleo, directed = T)
net3 <- adjToNetwork(paleo, directed = T, self_loops = T)

# add networks to a list
paleo_nets <- list("undirected" = net1, "directed" = net2, "self loops" = net3)

# Visualize the networks to show their different properties, for now make 
#   seperate visualizations for each network instead of showing them in a grid
anvis(paleo_nets, igr_grid = c(3,1), igr_grid_names = T)
```

For the `paleo` data having directed edges or self loops is not very informative,
as the adjacency matrix is symmetrical and all nodes have a perfect partial 
correlation with themselves. 
    
## Input of network objects

The functions of `anvis` allow network data of different classes as input, any
network of class `"graphNEL"`, `"igraph"`, or list of data frames `"vertices"` 
and `"edges"` will be valid. To make use of the full set of features of `anvis`,
networks will require and edge weight attribute. 

# Creating networks & Options for adding attributes 

- for vignette to showcase how you can edit parts of the visualizations use the paleo data, but then a partial correlation version of it. use the Mi paleo data for showing edge width algorithms
    - use sepsis when multiple networks are required

These attributes can all be added in a single step. To demonstrate the available options and their effect we list them below.


  
    
## Creating basic networks

* Adding edge directionality or self loops
    
    
## Node grouping

* group vector either one for all networks or one for each
* color of groups can be changed
* colorblind accessible option is available


## Node size

* How is connectivity calculated
* nodes can be arranged by size (connectivity)


## Edge width

* Explain the different types of methods that are available to calculate edge width
* there is an option available to rescale these edge widths
* The argument in the wrapper is vectorized
   
   
## Edge colors

### Available color spectra

* Diverging and sequential
    
### Changing edge colors with custom color function

* `Rcoloramp` can be used to convert colors to a spectrum. 
* demonstrate how to flip color spectra: 

```{r color_func}
# when the colors are opposite of what you expect
my_cols <- function (n) rev(pals::magma(n))
```

* Colors go from low to high values
* for positive and negative weights the colors are split into two halves, to be assigned to either sign


# Visualizing with igraph


## Changing the layout of the nodes

* Explain how alternative layouts can be used, and how the node order can be maintained


## Visualization of multiple networks

* Options to visualize side by side
* manually adjust the layout of the grid
* add titles to the grid elements, either by hand or from the names of the list
* Point out that it can be helpful to change the margins

## Further customization

* give some examples, to demonstrate that the full set of options of igraph is still available
    + Change graphical parameter options with `par()` 
    + Various options because of the flexibility of igraph
    + radial labels have their own options to be adjusted

## Directionality

* Arrows, self loops
* Recommend to use cytoscape instead of igraph since it looks neater



# Visualizing cytoscape


## Options for showing the visualizations

* Save image
    + export types
    + further export options
* Saving session
* Close session


## Visualization of multiple networks

* Multiple networks can be visualized, but they are either show in the session or saved seperately. No option to show side by side. 
* One option to show graphs side by side: - [arrange network windows](http://manual.cytoscape.org/en/stable/Quick_Tour_of_Cytoscape.html#:~:text=Arrange%20Network%20Windows)
* for easiest comparison we recommend igraph


## Directionality

* Arrows, self loops


## Customization 

* Setting more node space


## Using `r Biocpkg("RCy3")` for further customization

* Show at least one example to change some visual features of the network.


# Exporting the networks

* make a note on how the exports can include the columns that have info for visual styling
* Example with xgmml and another type
* file save name and xgmml title

##  saving of the visualizations

* export types
* further export options

# Session info

This vignette was made with `r CRANpkg("rmarkdown")` and `r Biocpkg("BiocStyle")`. Below the output generated by `sessionInfo()` when this document was compiled:

```{r sessionInfo, echo=FALSE}
sessionInfo()
```


